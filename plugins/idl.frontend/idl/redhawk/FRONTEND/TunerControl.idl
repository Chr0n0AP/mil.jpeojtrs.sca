/*
 * This file is protected by Copyright. Please refer to the COPYRIGHT file 
 * distributed with this source distribution.
 * 
 * This file is part of REDHAWK core.
 * 
 * REDHAWK core is free software: you can redistribute it and/or modify it 
 * under the terms of the GNU Lesser General Public License as published by the 
 * Free Software Foundation, either version 3 of the License, or (at your 
 * option) any later version.
 * 
 * REDHAWK core is distributed in the hope that it will be useful, but WITHOUT 
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License 
 * for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License 
 * along with this program.  If not, see http://www.gnu.org/licenses/.
 */

#ifndef _FRONTEND_TUNERCONTROL_IDL_
#define _FRONTEND_TUNERCONTROL_IDL_

#include "redhawk/FRONTEND/Frontend.idl" 
#include "ossie/BULKIO/bulkioDataTypes.idl"

module FRONTEND {

    /**
        Allocation call
        ---------------
        Capacity allocations for FEI 3.0 are to be made through the allocate() 
        method. If the allocation is successful, this method returns 
        information regarding the allocation, simplifying multiple aspects of 
        FEI management
        
        Mandated Structures and Ports:
        ------------------------------
        Frontend mandates four property structures outside of normal REDHAWK 
        properties of "device_kind" and "device_model" :
            (1) FRONTEND::tuner_allocation  - allocation structure to acquire 
            (capability on a tuner based off tuner settings. 	       
                    Name 
                        || ID 
                        || Type 
                        || Description
                    - tuner_type 
                        || FRONTEND::tuner_allocation::tuner_type 
                        || string 
                        || Example Tuner Types: TX, RX, RX_ARRAY, TX_ARRAY, 
                            RDC, ARDC, SRDC, DRDC, TDC, ABOT, DBOT
                    - center_frequency 
                        || FRONTEND::tuner_allocation::center_frequency 
                        || double 
                        || Requested center frequency in Hz
                    - bandwidth 
                        || FRONTEND::tuner_allocation::bandwidth 
                        || double 
                        || Requested Bandwidth in Hz
                    - bandwidth_tolerance 
                        || FRONTEND::tuner_allocation::bandwidth_tolerance 
                        || double 
                        || Allowable Percent above requested bandwidth 
                            (ie - 100 would be up to twice)
                    - sample_rate 
                        || FRONTEND::tuner_allocation::sample_rate 
                        || double 
                        || Requested sample rate in Hz. This can be ignored 
                            for such devices as analog tuners
                    - sample_rate_tolerance	
                        || FRONTEND::tuner_allocation::sample_rate_tolerance 
                        || double 
                        || Allowable Percent above requested sample rate 
                            (ie - 100 would be up to twice)
                    - device_control 
                        || FRONTEND::tuner_allocation::device_control 
                        || boolean 
                        || Value ignored - this is deprecated
                    - group_id 
                        || FRONTEND::tuner_allocation::group_id 
                        || string 
                        || Unique identifier that specifies a group of device. 
                            Must match group_id on the device
                    - rf_flow_id 
                        || FRONTEND::tuner_allocation::rf_flow_id 
                        || string 
                        || Optional. Specifies a certain RF flow to allocate 
                            against. If left empty, it will match all frontend 
                            devices. 
            (2) FRONTEND::scanner_allocation
                  Allocation structure to acquire capability on a scanning tuner 
                    (must be used in conjunction with FRONTEND::tuner_allocation).
                  Note that the allocation does not contain enough information 
                    to setup the scan strategy. Once the device is allocated, 
                    the strategy must be set through the control API
                    Name 
                        || ID 
                        || Type 
                        || Description
                    - min_freq 
                        || FRONTEND::scanner_allocation::min_freq 
                        || double 
                        || Requested lower edge of the scanning band
                    - max_freq 
                        || FRONTEND::scanner_allocation::max_freq 
                        || double 
                        || Requested upper edge of the scanning band
                    - mode 
                        || FRONTEND::scanner_allocation::mode 
                        || enum string 
                        || SPAN_SCAN or DISCRETE_SCAN
                    - control_mode 
                        || FRONTEND::scanner_allocation::control_mode 
                        || enum string
                        || TIME_BASED or SAMPLE_BASED
                    - control_limit 
                        || FRONTEND::scanner_allocation::control_limit 
                        || double 
                        || Either the fastest hop rate (TIME_BASED) or shortest 
                            set of samples (SAMPLE_BASED) that the scanner is 
                            expected to support. In samples, the number that 
                            will be needed before the next retune, equivalent 
                            to control_limit >= sample_rate/(max_settle_time+min_dwell_time) 
                            is met before the next retune
            (3) Additional allocation property (not a structure) to acquire 
                an arbitrary number of coherent feeds (i.e.: an array) that all 
                meet the tuner allocation criteria. Must be used in conjunction 
                with FRONTEND::tuner_allocation. May be used in conjuntion with 
                FRONTEND::scanner_allocation
                    Name 
                        || ID 
                        || Type 
                        || Description
                    - FRONTEND::coherent_feeds  
                        || FRONTEND::coherent_feeds 
                        || string sequence 
                        || rf_flow_id for request feeds. Use an empty string 
                            when the aperture name does not matter. The number 
                            of feeds allocated is the same as the number of 
                            strings in the sequence
            (4) FRONTEND::tuner_status - a struct sequence containing the 
                status of all tuners. There are optional and required fields 
                for this structure. The required fields are listed below:
                    Name 
                        || ID 
                        || Type 
                        || Description
                    - tuner_type 
                        || FRONTEND::tuner_status::tuner_type 
                        || string 
                        || Example Tuner Types: TX, RX, TX_ARRAY, RX_ARRAY, 
                            RDC, ARDC, SRDC, DRDC, TDC, ABOT, DBOT
                    - allocation_id_csv
                        || FRONTEND::tuner_status::allocation_id_csv
                        || string 
                        || allocation id (no longer a csv)
                    - center_frequency 
                        || FRONTEND::tuner_status::center_frequency 
                        || double 
                        || Current center frequency in Hz
                    - bandwidth 
                        || FRONTEND::tuner_status::bandwidth 
                        || double 
                        || Current Bandwidth in Hz
                    - sample_rate 
                        || FRONTEND::tuner_status::sample_rate 
                        || double 
                        || Current sample rate in Hz. This can be ignored for 
                            such devices as analog tuners
                    - group_id 
                        || FRONTEND::tuner_status::group_id 
                        || string 
                        || Unique identifier that specifies a group of device.
                    - rf_flow_id 
                        || FRONTEND::tuner_status::rf_flow_id 
                        || string 
                        || Specifies the RF flow id initially allocated against
                    - enabled 
                        || FRONTEND::tuner_status::enabled 
                        || boolean 
                        || True is tuner is enabled. Can be allocated but 
                            disabled 
                If the tuner supports scanning, the 
                    following optional fields are required as part of 
                    FRONTEND::tuner_status:
                    - scan_mode_enabled 
                        || FRONTEND::tuner_status::scan_mode_enabled 
                        || boolean 
                        || True is scan mode is enabled. False is Manual 
                            Tune is enabled 
                    - supports_scan 
                        || FRONTEND::tuner_status::supports_scan 
                        || boolean 
                        || True if scan is supported
            (6) FRONTEND::transmitter_allocation
                this allocation is no longer needed
                    Name 
                        || ID 
                        || Type 
                        || Description
                     - min_freq
                        || FRONTEND::transmitter_allocation::min_freq 
                        || double 
                        || In Hz. Requested lower edge of the transmit range
                     - max_freq
                        || FRONTEND::transmitter_allocation::max_freq 
                        || double 
                        || In Hz. Requested upper edge of the transmit range
                     - control_limit
                        || FRONTEND::transmitter_allocation::control_limit 
                        || double 
                        || In seconds. control_limit >= max_settle_time+min_dwell_time is met before the next retune
                     - max_power
                        || FRONTEND::transmitter_allocation::max_power 
                        || double 
                        || In Watts. max_power => transmitted power (-1 for ignore)
            (7) FRONTEND::listener_allocation is no longer needed but is still supported
                    Name 
                        || ID 
                        || Type 
                        || Description
                     - existing_allocation_id 
                        || FRONTEND::listener_allocation::existing_allocation_id 
                        || string 
                        || ignored
                     - listener_allocation_id 
                        || FRONTEND::listener_allocation::listener_allocation_id 
                        || string 
                        || ignored
        Usual port additions include a input (provides) port for the tuner 
            control as well as a BULKIO data port that follows the naming 
            convention [interface]_[in/out]. Examples include dataShort_out, 
            dataSDDS_out,  dataOctet_in, and DigitalTuner_in

        Tuner Types:
        ------------
        Frontend devices are separated in several tuner types based on 
            functionality. The base supported types are listed below but
            can be extended (ie - new types can be created) to satisfy
            one's CONOP
            - TX: Transmitter (analog input, analog output)
            - RX: Analog Receiver (analog input, analog output)
            - ABOT: Bank of tuners with an analog input (tuners are children like RDC)
            - DBOT: Bank of tuners with an digital input (tuners are children like RDC)
            - RDC: Receive Digital Channel (single digital output). Channel that is extracted from a 
                receiver (e.g.: ABOT or DBOT)
            - ARDC: Analog Receive Digital Channel (single digital output) from a single receiver
            - SRDC: Snapshot Receive Digital Channel (single digital output). RDC that extracts discrete snapshots
            - DRDC: Delayed Receive Digital Channel (single digital output). RDC with an arbitrary time delayed offset output
            - TDC: Transmit Digital Channel (single digital input). Channel that is transmitted (e.g.: TX)
            - TX_ARRAY: Aggregation of coherent transmitters
            - RX_ARRAY: Aggregation of coherent receivers

        Allocation ID:
        --------------
        The allocation id is contained in the allocation response.

        Data Ingress/Egress:
        ------------
        Devices contain a single data input or output:
        - RDC: single output
        - ARDC: single output
        - SRDC: single output
        - DRDC: single output
        - TDC: single input

        */


    /***********************/
    /**     CONSTANTS      */
    /***********************/
    
    /** Device Kind */
    const string FE_DEVICE_KIND = "FRONTEND";
    const string FE_PARENT_DEVICE_KIND = "FRONTEND::PARENT";

    /** Output format for digital tuners */
    const long REFERENCE_SOURCE_INTERNAL = 0; 
    const long REFERENCE_SOURCE_EXTERNAL = 1; 

    /** --- Tuner Types - Expandable list of supported FE types --- */
    const string TUNER_TYPE_TX = "TX"; 
    const string TUNER_TYPE_TX_ARRAY = "TX_ARRAY"; 
    const string TUNER_TYPE_RX = "RX"; 
    const string TUNER_TYPE_RX_ARRAY = "RX_ARRAY"; 
    const string TUNER_TYPE_DBOT = "DBOT"; 
    const string TUNER_TYPE_ABOT = "ABOT"; 
    const string TUNER_TYPE_RDC = "RDC"; 
    const string TUNER_TYPE_SRDC = "SRDC"; 
    const string TUNER_TYPE_ARDC = "ARDC"; 
    const string TUNER_TYPE_DRDC = "DRDC"; 
    const string TUNER_TYPE_TDC = "TDC"; 

    /*************************/
    /***      INTERFACE      */
    /*************************/

    interface FrontendTuner
    {
        /** Get the type of tuner (ie- RX or DDC) associated with this allocation id*/
        string getTunerType(in string id)
            raises (FrontendException, BadParameterException, NotSupportedException);
        
        /** Returns whether this allocation id has control (modification privledges) over the tuner*/
        boolean getTunerDeviceControl(in string id)
            raises (FrontendException, BadParameterException, NotSupportedException);
        
        /** Retrieves the group id (may be empty) for this allocation id */
        string getTunerGroupId(in string id)
            raises (FrontendException, BadParameterException, NotSupportedException);
            
        /** Retrieves the rf flow id (may be empty) for this allocation id */
        string getTunerRfFlowId(in string id)
            raises (FrontendException, BadParameterException, NotSupportedException);
        
        /** Key/Value pair of entire tuner status structure */
        CF::Properties getTunerStatus(in string id) 
            raises (FrontendException, BadParameterException, NotSupportedException);
    };
    
    
    interface AnalogTuner : FrontendTuner
    {

        /** Set/Get tuner center frequency */
        void    setTunerCenterFrequency(in string id, in double freq)
          raises (FrontendException, BadParameterException, NotSupportedException);
        double  getTunerCenterFrequency(in string id)
          raises (FrontendException, BadParameterException, NotSupportedException);

        /**  Set/Get tuner bandwidth */
        void    setTunerBandwidth(in string id, in double bw)
          raises (FrontendException, BadParameterException, NotSupportedException);
        double  getTunerBandwidth(in string id)
          raises (FrontendException, BadParameterException, NotSupportedException);

        /**  MGC/AGC  */
        void    setTunerAgcEnable(in string id, in boolean enable)
          raises (FrontendException, BadParameterException, NotSupportedException);
        boolean   getTunerAgcEnable(in string id)
          raises (FrontendException, BadParameterException, NotSupportedException);
        
        /**  MGC Gain (where negative gain is attenuation)*/
        void    setTunerGain(in string id, in float gain)
          raises (FrontendException, BadParameterException, NotSupportedException);
        float   getTunerGain(in string id)
          raises (FrontendException, BadParameterException, NotSupportedException);
   
        /**  Tuner Reference Source: 0 = internal,  1 = external*/
        void    setTunerReferenceSource(in string id, in long source)
          raises (FrontendException, BadParameterException, NotSupportedException);
        long    getTunerReferenceSource(in string id)
          raises (FrontendException, BadParameterException, NotSupportedException);

        /**  Enable/Disable Tuner - Expected to keep current tuner settings on a disable and an EOS to be sent */
        void    setTunerEnable(in string id, in boolean enable)
          raises (FrontendException, BadParameterException, NotSupportedException);
        boolean getTunerEnable(in string id)
          raises (FrontendException, BadParameterException, NotSupportedException);
    };


    interface DigitalTuner : AnalogTuner
    {
        /**  Set output sample rate  */
        void    setTunerOutputSampleRate(in string id,in double sr)
          raises (FRONTEND::FrontendException, FRONTEND::BadParameterException, FRONTEND::NotSupportedException);
        double  getTunerOutputSampleRate(in string id)
          raises (FRONTEND::FrontendException, FRONTEND::BadParameterException, FRONTEND::NotSupportedException);

        // atomically set the tuner's parameters like center frequency, bandwidth, sample rate, and gain
        // The available id/value pairs can be attained by calling getTunerSettings
        // The default key/value pairs are:
        //      id           value type       units       description
        //    CHAN_RF         double           Hz         tuned center frequency
        //      BW            double           Hz         receiver RF bandwidth
        //      SR            double         samples/s    sampling rate
        //     GAIN           double           dB         receiver gain
        // The complete list of supported key/value pairs is returned by getTunerSettings
        void    configureTuner(in string id,in CF::Properties tunerSettings)
          raises (FRONTEND::FrontendException, FRONTEND::BadParameterException, FRONTEND::NotSupportedException);
        CF::Properties getTunerSettings(in string id)
          raises (FRONTEND::FrontendException, FRONTEND::BadParameterException, FRONTEND::NotSupportedException);
    };

    /**
        TUNER SCAN MODE
        The tuner SCAN mode is being added to reduce aggregate tune delays when there is a need for a series of fast
        retunes. The objective is to let the tuner asset perform the retuning in an automated fashion.  

        The scan_mode property in the tuner_allocation structure is used for device allocation. If scan_mode is set to 
        "Scan" and the device has the capability, it will be allocated. The scan_rate property is also available in the 
        tuner_allocation structure. It is used as an allocation property if the user specifies a desired rate for the scan 
        operation. It is an optional allocation parameter.

        Tuner SCAN Mode allows the tuner to internally perform a scan where the tuner itself retunes to cover the desired
        spectrum. There are two types of automated scans: Span scan and discrete frequency scan, and a single non-automated scan: Manual (the way devices normally operate).
        The scan_mode_type value determines the scan type. If the only scanning that the device allows is manual, then the device does not support scanning.
        A Span scan is created using a series of start/stop frequencies. A Discrete Frequency Scan is created from a series of discrete 
        frequencies. Each of these inputs are used to create a series of center tune frequencies. Based on the selected bandwidth,
        the tuner scan generates as a series of center frequency retunes to cover the spectrum between the start/stop frequencies or
        discrete frequencies.

        The FRONTEND::tuner_status::scan_mode_enabled reflects whether the tuner is currently scanning through a plan that was generated to cover the spectrum.
        It will then tune, dwell for a specific number of samples based on the dwell setting and then move to the next center frequency.
        No output samples should be generated until the tuner settling time has been internally accounted for.

        start_time provides control over the tuner state and allows for synchronous sampling between multiple tuners.

        Scanning is enabled when the following conditions are met:
          1. FRONTEND::tuner_status::enabled is true
          2. scan_strategy.scan_mode != MANUAL_SCAN (note that the whole data structure must be passed on the call)
          3. start_time <= (BULKIO::PrecisionUTCTime) now
             alternatively, start_time = 0

        Scanning can be disabled by either:
          - FRONTEND::tuner_status::enabled is false (use setTunerEnable with the argument false)
          and/or
          - setting scan_strategy.scan_mode = MANUAL_SCAN
          and/or
          - start_time > (BULKIO::PrecisionUTCTime) now
            note: when the device's clock reaches start_time, the scan will start

        Also note that if the start_time is not set before setting the strategy, the scan plan will be executed as soon as the strategy is set.

        The ScanStatus structure contains the settings for the scan. 
    */

    interface ScanningTuner
    {
        /************************/
        /*      STRUCTURES      */
        /************************/
        enum ScanMode {
            MANUAL_SCAN,
            SPAN_SCAN,
            DISCRETE_SCAN
        };
        enum OutputControlMode {
            TIME_BASED,
            SAMPLE_BASED
        };
        /** Basic Scan Structure */
        /** Note: the bandwidth is set by the tuner base interface. The scanning interface manages the center frequency and duration of dwell **/
        struct ScanSpanRange {
            double begin_frequency;                 /* beginning center frequency for a Scan span (Hz) */
            double end_frequency;                   /* limit center frequency for a Scan span (Hz) */
            double step;                            /* change in center frequency (Hz) */
        };
        typedef sequence <ScanSpanRange> ScanSpanRanges;
        typedef sequence <double> Frequencies;

        union ScanModeDefinition switch(ScanMode) {
            case MANUAL_SCAN:
                double center_frequency;
            case SPAN_SCAN:
                ScanSpanRanges freq_scan_list;
            case DISCRETE_SCAN:
                Frequencies discrete_freq_list;
        };
        struct ScanStrategy {
            ScanMode            scan_mode;          /* determines the scan mode type: Manual: MANUAL_SCAN, Span Scan: SPAN_SCAN, Discrete Frequency Scan: DISCRETE_SCAN */
            ScanModeDefinition  scan_definition;    /* manual, span, or discrete frequency */
            OutputControlMode   control_mode;       /* time-based or sample-based */
            double              control_value;      /* time (in seconds) for time-based, or samples (truncated) for sample-based */
        };

        struct ScanStatus {
            ScanStrategy strategy;                  /* describes the scanning strategy (i.e.: time-based or sample-based) */
            BULKIO::PrecisionUTCTime start_time;    /* Scheduled (or actual) start */
            Frequencies center_tune_frequencies;    /* list of frequencies derived from the scanning plan (computed by the scanner device) */
            boolean started;                        /* True, scan plan in process */
        };

        ScanStatus getScanStatus(in string id)
          raises (FRONTEND::FrontendException, FRONTEND::BadParameterException, FRONTEND::NotSupportedException);

        /**  Set Tuner Scan Start Time. Set to time zero or any time in the past with a valid tcstatus flag to start immediately. Set to invalid tcstatus to disable  */
        void setScanStartTime(in string id,in BULKIO::PrecisionUTCTime start_time)
          raises (FRONTEND::FrontendException, FRONTEND::BadParameterException, FRONTEND::NotSupportedException);

        void setScanStrategy(in string id,in ScanStrategy scan_strategy)
          raises (FRONTEND::FrontendException, FRONTEND::BadParameterException, FRONTEND::NotSupportedException);
  };

  interface AnalogScanningTuner : ScanningTuner, AnalogTuner
  {
  };

  interface DigitalScanningTuner : ScanningTuner, DigitalTuner
  {
  };

    struct TransmitStatusType {
        string                      stream_id;
        string                      allocation_id;
        BULKIO::PrecisionUTCTime    timestamp;
        unsigned long long          total_samples;  // number of samples transmitted from this stream id; resets to 0 when >= max Ulonglong
        unsigned long long          total_packets;  // number of packets transmitted (pushPacket calls) from this stream id; resets to 0 when >= max Ulonglong
        boolean                     transmitting;   // true when currently transmitting, false when no queued data to transmit
        CF::DeviceStatusCodeType    status;         // device status
        double                      settling_time;  // this is the hardware's current re-tune settling time
        string                      message;        // message describing the error state
        unsigned long               queued_packets; // number of packets that are yet to be transmitted (current queue size)
    };

    interface TransmitDeviceStatus : CF::DeviceStatus {
        // triggers for status message: change in status, change in transmitting, or queued_packets increases or becomes zero
        void transmitStatusChanged(in TransmitStatusType status);
    };

    interface TransmitControl : DigitalTuner {
        struct TransmitParameters {
            string  stream_id;          // if empty string, then applies to all streams
            boolean ignore_timestamp;   // set to true for continuous data. Insufficient data will cause an UNDERFLOW error
            boolean ignore_error;       // set to true to ignore error states and just transmit
            double  tx_power;           // -1 for don't care
            double  max_timing_error;   // how much deviation (over/under) before MISSED_TRANSMIT_WINDOW is set as the error code; -1 for don't care
            // time for the packet transmission is the bulk io timestamp, unless ignore_timestamp is true; then data is sent as soon as it is available
            // center frequency for the packet transmission is CHAN_RF keyword in SRI
            // duration of the packet is the length of the packet * the sampling period (in SRI)
        };

        // reset allocation(s):
        //    - remove error codes
        //    - empty the transmit queue
        //    - reset total_samples count
        //    - reset total_packets count
        // if stream_id == "", the reset applies to all streams
        void reset(in string stream_id)
            raises (FRONTEND::FrontendException);

        // do not transmit the given stream id
        // queue the transmission until the stream id is allowed again
        //  return false if the stream id does not exist
        //  return true if the stream id exists
        boolean hold(in string stream_id)
            raises (FRONTEND::FrontendException);

        // list the stream ids that are currently in a "hold" state
        CF::StringSequence held()
            raises (FRONTEND::FrontendException);

        // allow the given stream id to transmit
        // if the transmission is queued, immediately transmit if timestamp is zero or set to ignore
        //  return false if the stream id does not exist
        //  return true if the stream id exists
        boolean allow(in string stream_id)
            raises (FRONTEND::FrontendException);

        void setTransmitParameters(in TransmitParameters transmit_parameters)
            raises (FRONTEND::FrontendException, FRONTEND::BadParameterException);

        TransmitParameters getTransmitParameters()
            raises (FRONTEND::FrontendException);
    };
};
#endif
